#!/bin/csh
#
#  last update = 5 Dec 2014
#
#  This is a C-shell script to execute GAMESS, by typing
#       rungms JOB VERNO NCPUS >& JOB.log &
#  JOB    is the name of the 'JOB.inp' file to be executed,
#  VERNO  is the number of the executable you chose at 'lked' time,
#  NCPUS  is the number of processors to be used.
#
#    b) choose a directory SCR where large temporary files can reside.
#       This should be the fastest possible disk access, very spacious,
#       and almost certainly a local disk.
#       Translation: do not put these files on a slow network file system!
#    c) choose a directory USERSCR on the file server where small ASCII
#       supplementary output files should be directed.
#       Translation: it is OK to put this on a network file system!
#
set TARGET=sockets
set SCR=/ssd        # location of temporary runtime files
set USERSCR=.   # location of text output files
set GMSPATH=/opt/gamess
#
set JOB=$1      # name of the input file xxx.inp, give only the xxx part
set NCPUS=4    # number of compute processes to be run
set VERNO=01    # revision number of the executable created by 'lked' step
#
#
#
echo "----- GAMESS execution script 'rungms' -----"
set master=`hostname`
echo This job is running on host $master
echo under operating system `uname` at `date`
#
#      Batch scheduler, if any, should provide its own working directory,
#      on every assigned node (if not, modify scheduler's prolog script).
#      The SCHED variable, and scheduler assigned work space, is used
#      below only in the MPI section.  See that part for more info.
set SCHED=none
echo "GAMESS temporary binary files will be written to $SCR"
echo "GAMESS supplementary output files will be written to $USERSCR"

#        this added as experiment, February 2007, as 8 MBytes
#        increased to 32 MB in October 2013 for the VB2000 code.
#        its intent is to detect large arrays allocated off the stack
limit stacksize 32768

#  Grab a copy of the input file.
#  In the case of examNN jobs, file is in tests/standard subdirectory.
#  In the case of exam-vbNN jobs, file is in vb2000's tests subdirectory.
if ($JOB:r.inp == $JOB) set JOB=$JOB:r      # strip off possible .inp
echo "Copying input file $JOB.inp to your run's scratch directory..."
if (-e $JOB.inp) then
   set echo
   cp  $JOB.inp  $SCR/$JOB.F05
   unset echo
else
   if (-e tests/standard/$JOB.inp) then
      set echo
      cp  tests/standard/$JOB.inp  $SCR/$JOB.F05
      unset echo
   else
      if (-e tests/$JOB.inp) then
         set echo
         cp  tests/$JOB.inp  $SCR/$JOB.F05
         unset echo
      else
         echo "Input file $JOB.inp does not exist."
         echo "This job expected the input file to be in directory `pwd`"
         echo "Please fix your file name problem, and resubmit."
         exit 4
      endif
   endif
endif

#    define many environment variables setting up file names.
#    anything can be overridden by a user's own choice, read 2nd.
#
source $GMSPATH/gms-files.csh
if (-e $HOME/.gmsrc) then
   echo "reading your own $HOME/.gmsrc"
   source $HOME/.gmsrc
endif
#
#    In case GAMESS has been interfaced to the Natural Bond Orbital
#    analysis program (http://www.chem.wisc.edu/~nbo6), you must
#    specify the full path name to the NBO binary.
#    This value is ignored if NBO has not been linked to GAMESS.
#
# setenv NBOEXE /u1/mike/nbo6/bin/nbo6.i8.exe
#
#        choose remote shell execution program.
#    Parallel run do initial launch of GAMESS on remote nodes by the
#    following program.  Note that the authentication keys for ssh
#    must have been set up correctly.
#    If you wish, choose 'rsh/rcp' using .rhosts authentication instead.
setenv DDI_RSH ssh
setenv DDI_RCP scp
#
#    If a $GDDI input group is present, the calculation will be using
#    subgroups within DDI (the input NGROUP=0 means this isn't GDDI).
#
#    The master within each group must have a copy of INPUT, which is
#    dealt with below (prior to execution), once we know something about
#    the host names where INPUT is required.  The INPUT does not have
#    the global rank appended to its name, unlike all other files.
#
#    OUTPUT and PUNCH (and perhaps many other files) are opened on all
#    processes (not just the master in each subgroup), but unique names
#    will be generated by appending the global ranks.  Note that OUTPUT
#    is not opened by the master in the first group, but is used by all
#    other groups.  Typically, the OUTPUT from the first group's master
#    is the only one worth saving, unless perhaps if runs crash out.
#
#    The other files that GDDI runs might use are already defined above.
#
set ngddi=`grep -i '^ \$GDDI' $SCR/$JOB.F05 | grep -iv 'NGROUP=0 ' | wc -l`
if ($ngddi > 0) then
   set GDDIjob=true
   echo "This is a GDDI run, keeping various output files on local disks"
   set echo
   setenv  OUTPUT $SCR/$JOB.F06
   setenv   PUNCH $SCR/$JOB.F07
   unset echo
else
   set GDDIjob=false
endif

#             replica-exchange molecular dynamics (REMD)
#     option is active iff runtyp=md as well as mremd=1 or 2.
#     It utilizes multiple replicas, one per subgroup.
#     Although REMD is indeed a GDDI kind of run, it handles its own
#     input file manipulations, but should do the GDDI file defs above.
set runmd=`grep -i runtyp=md $SCR/$JOB.F05 | wc -l`
set mremd=`grep -i mremd= $SCR/$JOB.F05 | grep -iv 'mremd=0 ' | wc -l`
if (($mremd > 0) && ($runmd > 0) && ($ngddi > 0)) then
   set GDDIjob=false
   set REMDjob=true
   echo "This is a REMD run, keeping various output files on local disks"
   set echo
   setenv TRAJECT     $SCR/$JOB.F04
   setenv RESTART $USERSCR/$JOB.rst
   setenv    REMD $USERSCR/$JOB.remd
   unset echo
   set GDDIinp=(`grep -i '^ \$GDDI' $JOB.inp`)
   set numkwd=$#GDDIinp
   @ g = 2
   @ gmax = $numkwd - 1
   while ($g <= $gmax)
      set keypair=$GDDIinp[$g]
      set keyword=`echo $keypair | awk '{split($1,a,"="); print a[1]}'`
      if (($keyword == ngroup) || ($keyword == NGROUP)) then
         set nREMDreplica=`echo $keypair | awk '{split($1,a,"="); print a[2]}'`
         @ g = $gmax
      endif
      @ g++
   end
   unset g
   unset gmax
   unset keypair
   unset keyword
else
   set REMDjob=false
endif

#    data left over from a previous run might be precious, stop if found.
if ((-e $PUNCH) || (-e $MAKEFP) || (-e $TRAJECT) || (-e $RESTART) ) then
   echo "Please save, rename, or erase these files from a previous run:"
   echo "     $PUNCH,"
   echo "     $TRAJECT,"
   echo "     $RESTART, and/or"
   echo "     $MAKEFP,"
   echo "and then resubmit this computation."
   exit 4
endif


if ($TARGET == sockets) then
#

   set os=`uname`
#         IBM's AIX needs special setting if node is more than a 4-way SMP

#         it is unlikely that you would need to change DDI_VER from 'new'!
#         some antique system lacking pthreads, for example, might have
#         to use the old DDI code, so we keep an execution example below.
   set DDI_VER='new'
#
#       1. Sequential execution is sure to be on this very same host
   if ($NCPUS == 1) then
      set NNODES=1
      set HOSTLIST=(`hostname`)
   endif
#
#       2. This is an example of how to run on a multi-core SMP enclosure,
#          where all CPUs (aka COREs) are inside a -single- NODE.
#     At other locations, you may wish to consider some of the examples
#     that follow below, after commenting out this ISU specific part.
#   if ($NCPUS > 1) then
#      switch (`hostname`)
#         case se.msg.chem.iastate.edu:
#         case sb.msg.chem.iastate.edu:
#            if ($NCPUS > 2) set NCPUS=2
#            set NNODES=1
#            set HOSTLIST=(`hostname`:cpus=$NCPUS)
#            breaksw
#         case br.msg.chem.iastate.edu:
#            if ($NCPUS > 8) set NCPUS=8
#            set NNODES=1
#            set HOSTLIST=(`hostname`:cpus=$NCPUS)
#            breaksw
#         case cd.msg.chem.iastate.edu:
#         case zn.msg.chem.iastate.edu:
#         case ni.msg.chem.iastate.edu:
#         case co.msg.chem.iastate.edu:
#         case pb.msg.chem.iastate.edu:
#         case bi.msg.chem.iastate.edu:
#         case po.msg.chem.iastate.edu:
#         case at.msg.chem.iastate.edu:
#         case sc.msg.chem.iastate.edu:
#            if ($NCPUS > 4) set NCPUS=4
#            set NNODES=1
#            set HOSTLIST=(`hostname`:cpus=$NCPUS)
#            breaksw
#         case ga.msg.chem.iastate.edu:
#         case ge.msg.chem.iastate.edu:
#         case gd.msg.chem.iastate.edu:
#            if ($NCPUS > 6) set NCPUS=6
#            set NNODES=1
#            set HOSTLIST=(`hostname`:cpus=$NCPUS)
#            breaksw
#         default:
#            echo I do not know how to run this node in parallel.
#            exit 20
#      endsw
#   endif



#       3. How to run in a single computer, namely the "localhost", so
#          this computer needn't have a proper Internet name.
#          This example also presumes SysV was deliberately *not* chosen
#          when DDI was compiled, so that host names have to be repeated,
#          instead of using the simpler localhost:cpus=$NCPU form.
#
#          This example is appropriate for use with the pre-compiled
#          Apple binary from our web site, provided it is uncommented,
#          and the passage #2 just above is deleted or commented out.
#
set HOSTLIST=()
@ n=1
while ($n <= $NCPUS)
   set HOSTLIST=($HOSTLIST localhost)
   @ n++
end
set NNODES=$NCPUS
#
#        Just make sure we have the binaries, before we try to run
#
if ((-x $GMSPATH/gamess.$VERNO.x) && (-x $GMSPATH/ddikick.x)) then
else
  echo The GAMESS executable gamess.$VERNO.x
  echo or else the DDIKICK executable ddikick.x
  echo could not be found in directory $GMSPATH,
  echo or else they did not properly link to executable permission.
  exit 8
endif
#
#        OK, now we are ready to execute!
#    The kickoff program initiates GAMESS process(es) on all CPUs/nodes.
#
if ($DDI_VER == new) then
  set echo
  $GMSPATH/ddikick.x $GMSPATH/gamess.$VERNO.x $JOB \
      -ddi $NNODES $NCPUS $HOSTLIST \
      -scr $SCR < /dev/null
  unset echo
else
  set path=($GMSPATH $path)
  set echo
  ddikick.x $JOB $GMSPATH gamess.$VERNO.x $SCR $NCPUS $HOSTLIST < /dev/null
  unset echo
endif
endif


echo ----- accounting info -----
#
#   in the case of GDDI runs, we save the first PUNCH file only.
#   If something goes wrong, the .F06.00x, .F07.00x, ... from the
#   other groups are potentially interesting to look at.
if ($GDDIjob == true) cp $SCR/$JOB.F07 $USERSCR/$JOB.dat
#
#   Clean up the master's scratch directory.
#
echo Files used on the master node $master were:
ls -lF $SCR/$JOB.*
rm -f  $SCR/$JOB.F*
#
#   Clean/Rescue any files created by the VB2000 plug-in
if (-e $SCR/$JOB.V84)        mv $SCR/$JOB.V84     $USERSCR
if (-e $SCR/$JOB.V80)        rm -f $SCR/$JOB.V*
if (-e $SCR/$JOB.TEMP02)     rm -f $SCR/$JOB.TEMP*
if (-e $SCR/$JOB.orb)        mv $SCR/$JOB.orb     $USERSCR
if (-e $SCR/$JOB.vec)        mv $SCR/$JOB.vec     $USERSCR
if (-e $SCR/$JOB.mol)        mv $SCR/$JOB.mol     $USERSCR
if (-e $SCR/$JOB.molf)       mv $SCR/$JOB.molf    $USERSCR
if (-e $SCR/$JOB.mkl)        mv $SCR/$JOB.mkl     $USERSCR
if (-e $SCR/$JOB.xyz)        mv $SCR/$JOB.xyz     $USERSCR
ls $SCR/${JOB}-*.cube > $SCR/${JOB}.lis
if (! -z $SCR/${JOB}.lis) mv $SCR/${JOB}*.cube $USERSCR
rm -f $SCR/${JOB}.lis
ls $SCR/${JOB}-*.grd > $SCR/${JOB}.lis
if (! -z $SCR/${JOB}.lis) mv $SCR/${JOB}*.grd $USERSCR
rm -f $SCR/${JOB}.lis
ls $SCR/${JOB}-*.csv > $SCR/${JOB}.lis
if (! -z $SCR/${JOB}.lis) mv $SCR/${JOB}*.csv $USERSCR
rm -f $SCR/${JOB}.lis
#
#  and this is the end
#
date
time
exit
